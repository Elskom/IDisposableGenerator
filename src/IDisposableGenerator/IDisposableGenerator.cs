namespace IDisposibleGenerator;

[Generator]
public class IDisposableGenerator : ISourceGenerator
{
    public void Execute(GeneratorExecutionContext context)
    {
        // retrieve the populated receiver
        var receiver = (context.SyntaxContextReceiver as SyntaxReceiver)!;

        // begin creating the source we'll inject into the users compilation
        StringBuilder sourceBuilder = new("// <autogenerated/>");
        foreach (var workItem in receiver.WorkItems)
        {
            _ = sourceBuilder.Append($@"
namespace {workItem.Namespace}
{{
    using global::System;
");
            foreach (var classItem in workItem.Classes)
            {
                _ = sourceBuilder.Append($@"
    {(classItem.Accessibility == Accessibility.Public ? "public" : "internal")} partial class {classItem.Name}{(!classItem.Stream ? " : IDisposable" : "")}
    {{
        private bool isDisposed;
");
                if (classItem.Owns.Any() && !classItem.Stream)
                {
                    _ = sourceBuilder.Append(@"
        internal bool IsOwned { get; set; }
");
                }
                else if (classItem.Owns.Any() && classItem.Stream)
                {
                    _ = sourceBuilder.Append(@"
        internal bool KeepOpen { get; }
");
                }

                _ = sourceBuilder.Append($@"
        {(!classItem.Stream ? $@"/// <summary>
        /// Cleans up the resources used by <see cref=""{classItem.Name}""/>.
        /// </summary>
        public void Dispose() => this.Dispose(true);

        private" : @"/// <inheritdoc/>
        protected override")} void Dispose(bool disposing)
        {{
            if (!this.isDisposed && disposing)
            {{
");
                if (classItem.Methods.Any())
                {
                    foreach (var methodItem in classItem.Methods)
                    {
                        _ = sourceBuilder.Append($@"                this.{methodItem}();
");
                    }
                }

                if (classItem.Owns.Any())
                {
                    _ = sourceBuilder.Append($@"                if (this.{(classItem.Stream ? "KeepOpen" : "IsOwned")})
                {{
");
                    foreach (var ownedItem in classItem.Owns)
                    {
                        // automatically set to null after Dispose().
                        _ = sourceBuilder.Append($@"                    this.{ownedItem}?.Dispose();
                    this.{ownedItem} = null;
");
                    }

                    _ = sourceBuilder.Append(@"                }
");
                }

                if (classItem.Fields.Any())
                {
                    foreach (var fieldItem in classItem.Fields)
                    {
                        // automatically set to null after Dispose().
                        _ = sourceBuilder.Append($@"                this.{fieldItem}?.Dispose();
                this.{fieldItem} = null;
");
                    }
                }

                if (classItem.SetNull.Any())
                {
                    foreach (var nullItem in classItem.SetNull)
                    {
                        _ = sourceBuilder.Append($@"                this.{nullItem} = null;
");
                    }
                }

                _ = sourceBuilder.Append(@"                this.isDisposed = true;
            }
");
                if (classItem.Stream)
                {
                    _ = sourceBuilder.Append(@"
            // On Streams call base.Dispose(disposing)!!!
            base.Dispose(disposing);
");
                }

                _ = sourceBuilder.Append(@"        }
    }
");
            }

            _ = sourceBuilder.Append(@"}
");
        }

        // inject the created source into the users compilation
        context.AddSource("Disposables.g.cs", sourceBuilder.ToString());
    }

    public void Initialize(GeneratorInitializationContext context)
        => context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
}
